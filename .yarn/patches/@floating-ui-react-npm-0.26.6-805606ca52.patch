diff --git a/dist/floating-ui.react.mjs b/dist/floating-ui.react.mjs
index 99a65995f6d6add8409934dc51fb466c9c742db1..d53c4aaca4cc33ea5862b43ef8a4edc83f9aa391 100644
--- a/dist/floating-ui.react.mjs
+++ b/dist/floating-ui.react.mjs
@@ -8,6 +8,22 @@ import { isElement, isHTMLElement, getNodeName, getWindow, isLastTraversableNode
 import { tabbable } from 'tabbable';
 import { createPortal, flushSync } from 'react-dom';
 
+const makeTransitioned = (og) => {
+  return (...args) => {
+    const [a, b] = og(...args)
+    const w = React.useCallback((...args) => {
+      let res
+      React.startTransition(() => {
+        res = b(...args)
+      })
+      return res
+    }, [b])
+    return [a, w]
+  }
+}
+const useStateAsync = makeTransitioned(React.useState)
+const useReducerAsync = makeTransitioned(React.useReducer)
+
 /**
  * Merges an array of refs into a single memoized callback ref or `null`.
  * @see https://floating-ui.com/docs/useMergeRefs
@@ -342,7 +358,7 @@ function FloatingList(_ref) {
     elementsRef,
     labelsRef
   } = _ref;
-  const [map, setMap] = React.useState(() => new Map());
+  const [map, setMap] = useStateAsync(() => new Map());
   const register = React.useCallback(node => {
     setMap(prevMap => new Map(prevMap).set(node, null));
   }, []);
@@ -377,7 +393,7 @@ function useListItem(_temp) {
   let {
     label
   } = _temp === void 0 ? {} : _temp;
-  const [index$1, setIndex] = React.useState(null);
+  const [index$1, setIndex] = useStateAsync(null);
   const componentRef = React.useRef(null);
   const {
     register,
@@ -447,7 +463,7 @@ const Composite = /*#__PURE__*/React.forwardRef(function Composite(_ref, forward
     dense = false,
     ...props
   } = _ref;
-  const [internalActiveIndex, internalSetActiveIndex] = React.useState(0);
+  const [internalActiveIndex, internalSetActiveIndex] = useStateAsync(0);
   const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
   const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
   const elementsRef = React.useRef([]);
@@ -600,7 +616,7 @@ let serverHandoffComplete = false;
 let count = 0;
 const genId = () => "floating-ui-" + count++;
 function useFloatingId() {
-  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : undefined);
+  const [id, setId] = useStateAsync(() => serverHandoffComplete ? genId() : undefined);
 
   // biome-ignore lint/correctness/useExhaustiveDependencies: intentional
   index(() => {
@@ -808,7 +824,7 @@ function FloatingTree(_ref2) {
   const removeNode = React.useCallback(node => {
     nodesRef.current = nodesRef.current.filter(n => n !== node);
   }, []);
-  const events = React.useState(() => createPubSub())[0];
+  const events = useStateAsync(() => createPubSub())[0];
   return /*#__PURE__*/React.createElement(FloatingTreeContext.Provider, {
     value: React.useMemo(() => ({
       nodesRef,
@@ -1157,7 +1173,7 @@ const FloatingDelayGroup = _ref => {
     delay,
     timeoutMs = 0
   } = _ref;
-  const [state, setState] = React.useReducer((prev, next) => ({
+  const [state, setState] = useReducerAsync((prev, next) => ({
     ...prev,
     ...next
   }), {
@@ -1475,7 +1491,7 @@ function setActiveElementOnTab(event) {
   }
 }
 const FocusGuard = /*#__PURE__*/React.forwardRef(function FocusGuard(props, ref) {
-  const [role, setRole] = React.useState();
+  const [role, setRole] = useStateAsync();
   index(() => {
     if (isSafari()) {
       // Unlike other screen readers such as NVDA and JAWS, the virtual cursor
@@ -1508,7 +1524,7 @@ function useFloatingPortalNode(_temp) {
     id,
     root
   } = _temp === void 0 ? {} : _temp;
-  const [portalNode, setPortalNode] = React.useState(null);
+  const [portalNode, setPortalNode] = useStateAsync(null);
   const uniqueId = useId();
   const portalContext = usePortalContext();
   const data = React.useMemo(() => ({
@@ -1578,7 +1594,7 @@ function FloatingPortal(_ref) {
     id,
     root
   });
-  const [focusManagerState, setFocusManagerState] = React.useState(null);
+  const [focusManagerState, setFocusManagerState] = useStateAsync(null);
   const beforeOutsideRef = React.useRef(null);
   const afterOutsideRef = React.useRef(null);
   const beforeInsideRef = React.useRef(null);
@@ -2270,8 +2286,8 @@ function useClientPoint(context, props) {
   } = props;
   const initialRef = React.useRef(false);
   const cleanupListenerRef = React.useRef(null);
-  const [pointerType, setPointerType] = React.useState();
-  const [reactive, setReactive] = React.useState([]);
+  const [pointerType, setPointerType] = useStateAsync();
+  const [reactive, setReactive] = useStateAsync([]);
   const setReference = useEffectEvent((x, y) => {
     if (initialRef.current) return;
 
@@ -2669,7 +2685,7 @@ function useFloating(options) {
       }
     }
   }
-  const [_domReference, setDomReference] = React.useState(null);
+  const [_domReference, setDomReference] = useStateAsync(null);
   const domReference = ((_options$elements2 = options.elements) == null ? void 0 : _options$elements2.reference) || _domReference;
   const position = useFloating$1(options);
   const tree = useFloatingTree();
@@ -2688,7 +2704,7 @@ function useFloating(options) {
   });
   const domReferenceRef = React.useRef(null);
   const dataRef = React.useRef({});
-  const events = React.useState(() => createPubSub())[0];
+  const events = useStateAsync(() => createPubSub())[0];
   const floatingId = useId();
   const setPositionReference = React.useCallback(node => {
     const positionReference = isElement(node) ? {
@@ -3068,8 +3084,8 @@ function useListNavigation(context, props) {
   const disabledIndicesRef = useLatestRef(disabledIndices);
   const latestOpenRef = useLatestRef(open);
   const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);
-  const [activeId, setActiveId] = React.useState();
-  const [virtualId, setVirtualId] = React.useState();
+  const [activeId, setActiveId] = useStateAsync();
+  const [virtualId, setVirtualId] = useStateAsync();
   const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {
     if (forceScrollIntoView === void 0) {
       forceScrollIntoView = false;
@@ -3623,7 +3639,7 @@ function execWithArgsOrReturn(valueOrFn, args) {
   return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;
 }
 function useDelayUnmount(open, durationMs) {
-  const [isMounted, setIsMounted] = React.useState(open);
+  const [isMounted, setIsMounted] = useStateAsync(open);
   if (open && !isMounted) {
     setIsMounted(true);
   }
@@ -3655,8 +3671,8 @@ function useTransitionStatus(context, props) {
   } = props;
   const isNumberDuration = typeof duration === 'number';
   const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
-  const [initiated, setInitiated] = React.useState(false);
-  const [status, setStatus] = React.useState('unmounted');
+  const [initiated, setInitiated] = useStateAsync(false);
+  const [status, setStatus] = useStateAsync('unmounted');
   const isMounted = useDelayUnmount(open, closeDuration);
 
   // `initiated` check prevents this `setState` call from breaking
@@ -3714,7 +3730,7 @@ function useTransitionStyles(context, props) {
   const isNumberDuration = typeof duration === 'number';
   const openDuration = (isNumberDuration ? duration : duration.open) || 0;
   const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
-  const [styles, setStyles] = React.useState(() => ({
+  const [styles, setStyles] = useStateAsync(() => ({
     ...execWithArgsOrReturn(unstable_common, fnArgs),
     ...execWithArgsOrReturn(unstable_initial, fnArgs)
   }));
